"""DHCP configuration parser and serializer"""
import re
from typing import List, Tuple, Optional
import uuid

from app.models.dhcp import DHCPSubnet, DHCPReservation, DHCPLease


def parse_dhcpd_conf(content: str) -> Tuple[List[DHCPSubnet], List[DHCPReservation]]:
    """Parse dhcpd.conf content.
    
    Args:
        content: dhcpd.conf file content
        
    Returns:
        Tuple of (subnets, reservations)
    """
    subnets = []
    reservations = []
    
    # Parse subnet blocks
    subnet_pattern = r'subnet\s+(\d+\.\d+\.\d+\.\d+)\s+netmask\s+(\d+\.\d+\.\d+\.\d+)\s*\{([^}]+)\}'
    for match in re.finditer(subnet_pattern, content, re.DOTALL):
        network = match.group(1)
        netmask = match.group(2)
        block = match.group(3)
        
        # Стабильный ID на основе network/netmask
        subnet = DHCPSubnet(
            id=f"{network}_{netmask}",
            network=network,
            netmask=netmask,
        )
        
        # Parse range
        range_match = re.search(r'range\s+(\d+\.\d+\.\d+\.\d+)\s+(\d+\.\d+\.\d+\.\d+)', block)
        if range_match:
            subnet.range_start = range_match.group(1)
            subnet.range_end = range_match.group(2)
        
        # Parse options
        routers_match = re.search(r'option\s+routers\s+(\d+\.\d+\.\d+\.\d+)', block)
        if routers_match:
            subnet.routers = routers_match.group(1)
        
        dns_match = re.search(r'option\s+domain-name-servers\s+([^;]+)', block)
        if dns_match:
            subnet.domain_name_servers = dns_match.group(1).strip()
        
        domain_match = re.search(r'option\s+domain-name\s+"([^"]+)"', block)
        if domain_match:
            subnet.domain_name = domain_match.group(1)
        
        lease_match = re.search(r'default-lease-time\s+(\d+)', block)
        if lease_match:
            subnet.default_lease_time = int(lease_match.group(1))
        
        max_lease_match = re.search(r'max-lease-time\s+(\d+)', block)
        if max_lease_match:
            subnet.max_lease_time = int(max_lease_match.group(1))
        
        subnets.append(subnet)
    
    # Parse host blocks (reservations)
    host_pattern = r'host\s+(\S+)\s*\{([^}]+)\}'
    for match in re.finditer(host_pattern, content, re.DOTALL):
        hostname = match.group(1)
        block = match.group(2)
        
        mac_match = re.search(r'hardware\s+ethernet\s+([0-9a-fA-F:]+)', block)
        ip_match = re.search(r'fixed-address\s+(\d+\.\d+\.\d+\.\d+)', block)
        
        if mac_match and ip_match:
            mac = mac_match.group(1)
            reservation = DHCPReservation(
                id=mac.lower().replace(":", "-"),  # Используем MAC как ID
                hostname=hostname,
                mac=mac,
                ip=ip_match.group(1),
            )
            reservations.append(reservation)
    
    return subnets, reservations


def serialize_dhcpd_conf(
    subnets: List[DHCPSubnet],
    reservations: List[DHCPReservation],
    global_options: Optional[str] = None,
) -> str:
    """Serialize subnets and reservations to dhcpd.conf format.
    
    Args:
        subnets: List of subnets
        reservations: List of reservations
        global_options: Optional global options to include at the top
        
    Returns:
        dhcpd.conf content string
    """
    lines = []
    
    # Global options
    if global_options:
        lines.append(global_options)
        lines.append("")
    else:
        lines.append("# DHCP Server Configuration")
        lines.append("# Generated by LDC Panel")
        lines.append("")
        lines.append("authoritative;")
        lines.append("")
    
    # Subnets
    for subnet in subnets:
        lines.append(f"subnet {subnet.network} netmask {subnet.netmask} {{")
        
        if subnet.range_start is not None and subnet.range_end is not None:
            lines.append(f"    range {subnet.range_start} {subnet.range_end};")
        
        if subnet.routers:
            lines.append(f"    option routers {subnet.routers};")
        
        if subnet.domain_name_servers:
            lines.append(f"    option domain-name-servers {subnet.domain_name_servers};")
        
        if subnet.domain_name:
            lines.append(f'    option domain-name "{subnet.domain_name}";')
        
        lines.append(f"    default-lease-time {subnet.default_lease_time};")
        lines.append(f"    max-lease-time {subnet.max_lease_time};")
        
        lines.append("}")
        lines.append("")
    
    # Reservations
    for reservation in reservations:
        lines.append(f"host {reservation.hostname} {{")
        lines.append(f"    hardware ethernet {reservation.mac};")
        lines.append(f"    fixed-address {reservation.ip};")
        lines.append("}")
        lines.append("")
    
    return "\n".join(lines)


def parse_dhcpd_leases(content: str) -> List[DHCPLease]:
    """Parse dhcpd.leases file content.
    
    Args:
        content: dhcpd.leases file content
        
    Returns:
        List of active leases
    """
    leases = []
    
    # Parse lease blocks
    lease_pattern = r'lease\s+(\d+\.\d+\.\d+\.\d+)\s*\{([^}]+)\}'
    for match in re.finditer(lease_pattern, content, re.DOTALL):
        ip = match.group(1)
        block = match.group(2)
        
        lease = DHCPLease(ip=ip, mac="", state="active")
        
        # Parse MAC
        mac_match = re.search(r'hardware\s+ethernet\s+([0-9a-fA-F:]+)', block)
        if mac_match:
            lease.mac = mac_match.group(1)
        
        # Parse hostname
        hostname_match = re.search(r'client-hostname\s+"([^"]+)"', block)
        if hostname_match:
            lease.hostname = hostname_match.group(1)
        
        # Parse times
        starts_match = re.search(r'starts\s+\d+\s+([^;]+)', block)
        if starts_match:
            lease.starts = starts_match.group(1).strip()
        
        ends_match = re.search(r'ends\s+\d+\s+([^;]+)', block)
        if ends_match:
            lease.ends = ends_match.group(1).strip()
        
        # Check binding state
        state_match = re.search(r'binding\s+state\s+(\w+)', block)
        if state_match:
            lease.state = state_match.group(1)
        
        # Only include active leases
        if lease.state == "active" and lease.mac:
            leases.append(lease)
    
    return leases
